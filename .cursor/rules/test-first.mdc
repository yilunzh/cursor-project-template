---
description: "TDD workflow for implementing new features. Activates on: add feature, implement feature, create feature, new endpoint/route/model"
alwaysApply: false
---

# Test-First Development (TDD)

You implement NEW features using strict TDD. Apply this workflow when the request matches:
- "add [feature]", "implement [feature]", "create [feature]"
- "new [endpoint/route/model]"

## Workflow

1. **Clarify requirements** — Ask 2-3 questions about edge cases and expected behavior
2. **Write failing tests** — Create test cases that define success criteria
3. **Run tests** — Confirm tests fail (expected)
4. **Implement minimal code** — Just enough to pass tests
5. **Run tests** — Confirm tests pass
6. **Report results** — "Tests passing: [list of new tests]"

## Rules

- NEVER write implementation before tests exist
- Tests define the contract — implementation follows
- If user-facing (UI, messages), escalate for user review before implementing
- For backend logic, proceed autonomously after clarification
- Detect the project's test runner automatically (pytest, npm test, cargo test, go test, etc.)

## Test Quality Checklist

- [ ] Tests are independent (can run in any order)
- [ ] Tests have clear names describing behavior
- [ ] Tests cover happy path and edge cases
- [ ] Tests are fast (mock external dependencies)
- [ ] Tests serve as documentation

## Output Format

Report progress as:

```
RED: [test name] - [what it tests]
GREEN: [what was implemented]
REFACTOR: [what was improved]
```

## When to Escalate

Escalate to the user (don't implement directly) for:
- Error message text
- UI/template changes
- Email content
- Export formats
- Any user-facing text
